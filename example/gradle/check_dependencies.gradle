class Dependency {
    String name
    String group
    String currentVersion
    String availableVersion
    String changelog
}

def normalizeURL = { String url ->
    if (url == null) return ""

    def size = url.length()

    if ("${url.charAt(size - 1)}" == "/") {
        return url.substring(0, size - 1)
    } else {
        return url
    }
}

def generateJSON = { Dependency dependency ->
    return "{" +
            "\"group\": " + "\"" + dependency.group + "\"," +
            "\"name\": " + "\"" + dependency.name + "\"," +
            "\"currentVersion\": " + "\"" + dependency.currentVersion + "\"," +
            "\"availableVersion\": " + "\"" + dependency.availableVersion + "\"," +
            "\"changelog\": " + "\"" + dependency.changelog + "\"" +
            "}"
}

def dependenciesDenylist = [
        // Beta/RC/weird versions
        (String dependency, String currentVersion, String newVersion) -> {
            def stableKeywords = ['RELEASE', 'FINAL', 'GA']
            def versionRegex = /^[0-9,.v-]+(-r)?$/

            def isNewVersionStable = stableKeywords.any { it -> newVersion.toUpperCase().contains(it) } || (newVersion ==~ versionRegex)
            def isCurrentVersionStable = stableKeywords.any { it -> currentVersion.toUpperCase().contains(it) } || (currentVersion ==~ versionRegex)

            return !(isNewVersionStable || !isNewVersionStable && !isCurrentVersionStable)
        }
]

def dependenciesChangelog = [
        (String url, String installedVersion, String newVersion, String group) -> { return url.contains("#") ? url : null },
        (String url, String installedVersion, String newVersion, String group) -> {
            return url.contains("https://github.com/") ? "$url/releases/tag/$newVersion" : null
        },
        (String url, String installedVersion, String newVersion, String group) -> {
            def library = group.split('\\.')
            def parsedVersion = newVersion.replace(".", "")

            // Kotlin
            if (url.contains("https://kotlinlang.org")) return "https://kotlinlang.org/docs/releases.html#release-details"

            // Firebase
            if (group.contains("com.google.firebase")) return "https://firebase.google.com/support/release-notes/android"

            // GMS
            if (group.contains("com.google.gms")) return "https://developers.google.com/android/guides/releases"

            //Espresso & Others
            if (group.contains("androidx.test") && library.length > 0) {
                return "https://developer.android.com/jetpack/androidx/releases/test#${library[library.length - 1]}-$newVersion"
            }

            //JUnit
            if (group.contains("org.junit.jupiter")) {
                return "https://junit.org/junit5/docs/snapshot/release-notes/index.html#release-notes-$newVersion"
            }

            // Square libs (OkHttp, etc...)
            if (url.contains("square.github.io")) return "$url/changelog/#version-$parsedVersion"
            if (url.contains("leakcanary")) return "https://square.github.io/leakcanary/changelog/"

            return null
        },
        (String url, String installedVersion, String newVersion, String group) -> { return url }
]

tasks.named("dependencyUpdates").configure {
    resolutionStrategy {
        componentSelection {
            all { dependency ->
                def discard = dependenciesDenylist.stream()
                        .filter { predicate ->
                            predicate(
                                    dependency.candidate.group + ":" + dependency.candidate.module,
                                    dependency.currentVersion,
                                    dependency.candidate.version
                            )
                        }
                        .count() > 0

                if (discard) {
                    reject('The depency version is present in the denylist filters.')
                }
            }
        }
    }

    outputFormatter = { result ->
        def updatable = result.outdated.dependencies

        def outputDirectory = new File("${rootProject.buildDir}/dependencies/")
        def outputFile = new File(outputDirectory, "report.json")
        def isAppendMode = outputFile.exists()

        outputDirectory.mkdirs()
        outputFile.createNewFile()

        if (!updatable.isEmpty()) {
            def json = ""

            if (!isAppendMode || outputFile.text.size() == 0) {
                json += "["
            } else {
                def previousJson = outputFile.text
                def suffixChar = previousJson.length() > 2 ? "," : ""

                json += previousJson.substring(0, previousJson.length() - 1) + suffixChar
            }

            updatable.stream()
                    .map { dependency ->
                        def version = (dependency.available.release ?: dependency.available.milestone)
                        def url = normalizeURL(dependency.projectUrl)

                        def changelogPredicate = dependenciesChangelog.stream()
                                .filter { predicate ->
                                    predicate(url, dependency.version, version, dependency.group) != null
                                }
                                .toArray()[0]

                        return new Dependency(
                                name: dependency.name,
                                group: dependency.group,
                                currentVersion: dependency.version,
                                availableVersion: version,
                                changelog: changelogPredicate(url, dependency.version, version, dependency.group)
                        )
                    }
                    .eachWithIndex { dependency, index ->
                        def generatedJson = generateJSON(dependency)

                        if (!json.contains(generatedJson)) {
                            json += generatedJson + ","
                        }
                    }

            if (json.length() > 0 && json.substring(json.length() - 1) == ",") {
                json = json.substring(0, json.length() - 1)
            }

            json += "]"

            // We aren't handling duplicates on the output json file.
            // For the dependencies script thats no problem since we are handling it there.
            // If you end up using this json for something else take this into account
            outputFile.write(json.toString())
        }
    }
}
